// Copyright 2025 Mohammad Shafiee. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"math/big"
	"os"
)

// Generate power-of-5 tables for the Ryū algorithm
// These tables are used for fast float-to-decimal conversion

func main() {
	f, err := os.Create("ryu_tables_generated.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by generate_tables.go; DO NOT EDIT.")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "package ryu")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "// Power of 5 tables for Ryū algorithm")
	fmt.Fprintln(f, "// These are pre-computed to avoid expensive exponentiation")
	fmt.Fprintln(f, "")

	// Constants
	fmt.Fprintln(f, "const (")
	fmt.Fprintln(f, "\tPOW5_BITCOUNT     = 121 // Number of bits in each table entry")
	fmt.Fprintln(f, "\tPOW5_INV_BITCOUNT = 122 // Number of bits for inverse table")
	fmt.Fprintln(f, "\tDOUBLE_POW5_TABLE_SIZE = 326")
	fmt.Fprintln(f, "\tDOUBLE_POW5_INV_TABLE_SIZE = 342")
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f, "")

	// Generate pow5Split table (multiplication by 5^e)
	generatePow5Split(f)

	// Generate pow5InvSplit table (division by 5^e, i.e., multiplication by 5^-e)
	generatePow5InvSplit(f)
}

func generatePow5Split(f *os.File) {
	fmt.Fprintln(f, "// pow5Split contains the high 128 bits of 5^e for e in [0, 325]")
	fmt.Fprintln(f, "// Used for multiplication by powers of 5")
	fmt.Fprintln(f, "var pow5Split = [DOUBLE_POW5_TABLE_SIZE][2]uint64{")

	one := big.NewInt(1)
	shift := big.NewInt(0).Lsh(one, 121) // 2^121
	five := big.NewInt(5)
	power := big.NewInt(1)

	for i := 0; i < 326; i++ {
		// Calculate 5^i * 2^121 to get high bits
		val := big.NewInt(0).Mul(power, shift)

		// We need the high 128 bits, so divide by 2^121 to get back scaled value
		// Then extract high 64 and low 64 bits

		// Get the bit length
		bitLen := val.BitLen()

		var hi, lo uint64
		if bitLen > 121 {
			// Shift right by 121 to get the high bits
			shifted := big.NewInt(0).Rsh(val, 121)

			// Extract low 64 bits
			lo64 := big.NewInt(0).And(shifted, big.NewInt(0).Sub(big.NewInt(0).Lsh(one, 64), one))
			lo = lo64.Uint64()

			// Extract high 64 bits
			hi64 := big.NewInt(0).Rsh(shifted, 64)
			if hi64.BitLen() > 0 && hi64.BitLen() <= 64 {
				hi = hi64.Uint64()
			} else {
				hi = 0
			}
		} else {
			hi = 0
			lo = power.Uint64()
			if lo == 0 && i == 0 {
				lo = 1 // 5^0 = 1
			}
		}

		fmt.Fprintf(f, "\t{0x%x, 0x%x}, // 5^%d\n", hi, lo, i)

		// Next power: multiply by 5
		power.Mul(power, five)
	}

	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "")
}

func generatePow5InvSplit(f *os.File) {
	fmt.Fprintln(f, "// pow5InvSplit contains the high 128 bits of ceil(2^(e+121) / 5^e) for e in [0, 341]")
	fmt.Fprintln(f, "// Used for division by powers of 5 (multiplication by 5^-e)")
	fmt.Fprintln(f, "var pow5InvSplit = [DOUBLE_POW5_INV_TABLE_SIZE][2]uint64{")

	one := big.NewInt(1)
	five := big.NewInt(5)
	power := big.NewInt(1)

	for i := 0; i < 342; i++ {
		// Calculate ceil(2^(i + 121) / 5^i)
		// = ceil(2^(i + 121) / 5^i)

		numerator := big.NewInt(0).Lsh(one, uint(i+121))

		// Divide and take ceiling
		quotient := big.NewInt(0).Div(numerator, power)
		remainder := big.NewInt(0).Mod(numerator, power)

		if remainder.Sign() > 0 {
			quotient.Add(quotient, one) // Ceiling
		}

		// Extract high 64 and low 64 bits
		lo64 := big.NewInt(0).And(quotient, big.NewInt(0).Sub(big.NewInt(0).Lsh(one, 64), one))
		lo := lo64.Uint64()

		hi64 := big.NewInt(0).Rsh(quotient, 64)
		var hi uint64
		if hi64.BitLen() > 0 && hi64.BitLen() <= 64 {
			hi = hi64.Uint64()
		} else {
			hi = 0
		}

		fmt.Fprintf(f, "\t{0x%x, 0x%x}, // ceil(2^%d / 5^%d)\n", hi, lo, i+121, i)

		// Next power: multiply by 5
		power.Mul(power, five)
	}

	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "")
}
